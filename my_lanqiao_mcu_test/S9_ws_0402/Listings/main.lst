C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2024 16:27:45 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\c51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\
                    -main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          /*
   2          1）把每个赛题程序都当成  竞赛时的最终上传程序
   3          2）工程包含的模块只能是竞赛时会写出来的模块
   4          3）题目要逐行仔细分析，注意每一个细节要求。
   5          4）程序编好后，认真修改，严格要求。
   6          5）参考的只能是思路，实现要完全靠自己。
   7          6）重要内容要有注释
   8          */
   9          
  10          #include "all.h"
  11          //
  12          volatile u8 bdata led_dat = 0;
  13          sbit L1 = led_dat ^0;
  14          sbit L2 = led_dat ^1;
  15          sbit L3 = led_dat ^2;
  16          sbit L4 = led_dat ^3;
  17          sbit L5 = led_dat ^4;
  18          sbit L6 = led_dat ^5;
  19          sbit L7 = led_dat ^6;
  20          sbit L8 = led_dat ^7;
  21          //
  22          u8 bdata blink8_dat=0;
  23          //
  24          xdata struct _cj x;
  25          bit f_s4L = 0;
  26          //
  27          //
  28          u8 led1[8] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  29          u8 led2[4] = {0x18,0x24,0x42,0x81};
  30          u8 run_state = 0;
  31          bit f_led_t = 0;
  32          //
  33          void main_init(void);
  34          void state_mainloop(void);
  35          void key_mainloop(void);
  36          //
  37          void led_mainloop(void);
  38          //
  39          void adc_mainloop(void);
  40          void blink8_mainloop(void);
  41          
  42          void Delay10ms(void);
  43          void e2prom_init(void);
  44          //*******************************
  45          void main(void)
  46          {
  47   1      
  48   1              main_init();
  49   1              EA = 1;
  50   1              while(1)
  51   1              {
  52   2                      state_mainloop();
  53   2                      key_mainloop();
  54   2                      led_mainloop();
C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2024 16:27:45 PAGE 2   

  55   2                      blink8_mainloop();
  56   2                      adc_mainloop();
  57   2              }
  58   1      }
  59          //****************************
  60          void main_init(void)
  61          {
  62   1              off(JDQ);off(FMQ);
  63   1              led_dat = 0;    
  64   1              Timer1_Init();
  65   1              init_adc(0x03);//RB2
  66   1      
  67   1              e2prom_init();
  68   1              run_state = 10;
  69   1              x.l = 0;
  70   1              x.f_on = 0xff;//允许开关灯
  71   1              x.adc = 0;
  72   1              x.mode = 1;
  73   1              x.m_set = 1;
  74   1      
  75   1      }
  76          //****************************
  77          void state_mainloop(void)
  78          {
  79   1              if(!f_100ms_state)return;
  80   1              f_100ms_state = 0;
  81   1              switch(run_state)
  82   1              {
  83   2                      case 10://显示界面
  84   2                              sprintf(dis_str,"        ");
  85   2                      break;
  86   2                      case 20://设置界面//模式
  87   2                              switch(x.m_set)
  88   2                              {
  89   3                                      case 1:sprintf(dis_str,"-%1bu- %4d",x.m_set,x.t1*100);break;
  90   3                                      case 2:sprintf(dis_str,"-%1bu- %4d",x.m_set,x.t2*100);break;
  91   3                                      case 3:sprintf(dis_str,"-%1bu- %4d",x.m_set,x.t3*100);break;
  92   3                                      case 4:sprintf(dis_str,"-%1bu- %4d",x.m_set,x.t4*100);break;
  93   3                              }
  94   2                      break;
  95   2                      case 21://设置界面//流转间隔
  96   2                              sprintf(dis_str,"-%1bu- %4d",x.m_set,x.t_set*100);
  97   2                      break;
  98   2                      case 30:
  99   2                              sprintf(dis_str,"      -%1bu",x.l);
 100   2                      break;
 101   2              }
 102   1              disp_tran();
 103   1      }
 104          //******************************
 105          void key_mainloop(void)
 106          {
 107   1              if(!f_20ms_key)return;
 108   1              f_20ms_key = 0;
 109   1              
 110   1              key_proc();
 111   1              if(!key_code)return;
 112   1              
 113   1              switch(key_code)
 114   1              {
 115   2                      case S4:
 116   2                              switch(run_state)
C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2024 16:27:45 PAGE 3   

 117   2                              {
 118   3                                      case 20://模式
 119   3                                      if(x.m_set++ >= 4)x.m_set = 4;
 120   3                                      break;
 121   3                                      case 21://时间
 122   3                                      if(x.t_set++ >= 12)x.t_set = 12;        //1200ms
 123   3                                      break;
 124   3                              }
 125   2                      break;
 126   2                      case S5:
 127   2                              switch(run_state)
 128   2                              {
 129   3                                      case 20:
 130   3                                      if(x.m_set-- <= 1)x.m_set= 1;   
 131   3                                      break;
 132   3                                      case 21:
 133   3                                      if(x.t_set-- <= 4)x.t_set = 4;  //400ms
 134   3                                      break;
 135   3                              }
 136   2                      break;
 137   2                      case S6:
 138   2                              switch(run_state)
 139   2                              {
 140   3                                      case 10:run_state = 20;blink8_dat = 0x07;
 141   3                                      break;
 142   3                                      case 20:run_state = 21;blink8_dat = 0xf0;
 143   3                                                      switch(x.m_set)
 144   3                                                      {
 145   4                                                              case 1:x.t_set=x.t1;break;
 146   4                                                              case 2:x.t_set=x.t2;break;
 147   4                                                              case 3:x.t_set=x.t3;break;
 148   4                                                              case 4:x.t_set=x.t4;break;
 149   4                                                      }
 150   3                                      break;
 151   3                                      case 21:run_state = 10;
 152   3                                                      blink8_dat = 0;
 153   3                                                      switch(x.m_set)
 154   3                                                      {
 155   4                                                              case 1:write_e2prom(x.m_set,x.t1);x.t1=x.t_set;break;//写入时间间隔保存
 156   4                                                              case 2:write_e2prom(x.m_set,x.t2);x.t2=x.t_set;break;//写入时间间隔保存
 157   4                                                              case 3:write_e2prom(x.m_set,x.t3);x.t3=x.t_set;break;//写入时间间隔保存
 158   4                                                              case 4:write_e2prom(x.m_set,x.t4);x.t4=x.t_set;break;//写入时间间隔保存
 159   4                                                      }
 160   3                                      break;//保存返回
 161   3                              }
 162   2                      break;
 163   2                      case S7:
 164   2                              x.f_on = ~x.f_on;
 165   2                      break;
 166   2                      
 167   2                      case S4L:
 168   2                              switch(run_state)
 169   2                              {
 170   3                                      case 10:run_state=40; break;
 171   3                              }
 172   2                      break;
 173   2              }
 174   1              key_code = 0;
 175   1      }
 176          //*************************
 177          void led_mainloop(void)
 178          {
C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2024 16:27:45 PAGE 4   

 179   1              static int cnt_t = 0;
 180   1              static u8 i = 0;
 181   1              
 182   1              if(!f_100ms_led)return;
 183   1              f_100ms_led = 0;
 184   1              
 185   1              switch(x.mode)
 186   1              {
 187   2                      case 1:
 188   2                              if(++cnt_t >= x.t1)//流转间隔判断
 189   2                              {
 190   3                                      cnt_t = 0;f_led_t = 1;
 191   3                              }else f_led_t = 0;
 192   2                              led_dat = led1[i];
 193   2                      break;
 194   2                      case 2:
 195   2                              if(++cnt_t >= x.t2)//流转间隔判断
 196   2                              {
 197   3                                      cnt_t = 0;f_led_t = 1;
 198   3                              }else f_led_t = 0;
 199   2                              led_dat = led1[i];
 200   2                      break;
 201   2                      case 3:
 202   2                              if(++cnt_t >= x.t3)//流转间隔判断
 203   2                              {
 204   3                                      cnt_t = 0;f_led_t = 1;
 205   3                              }else f_led_t = 0;
 206   2                              led_dat = led2[i];
 207   2                      break;
 208   2                      case 4:
 209   2                              if(++cnt_t >= x.t4)//流转间隔判断
 210   2                              {
 211   3                                      cnt_t = 0;f_led_t = 1;
 212   3                              }else f_led_t = 0;
 213   2                              led_dat = led2[i];
 214   2                      break;
 215   2                      default:led_dat = 0;break;
 216   2              }
 217   1              
 218   1              if(!x.f_on)return;//S7启停,即i不在加减
 219   1              if(f_led_t)//流转间隔
 220   1              {
 221   2                      f_led_t = 0;
 222   2                      switch(x.mode)
 223   2                      {
 224   3                              case 1:                 
 225   3                                      if(++i > 7) 
 226   3                                      {i=7;x.mode=2;}
 227   3                              break;
 228   3                              case 2:
 229   3                                      if(--i > 7) 
 230   3                                      {i=4;x.mode=3;}
 231   3                              break;
 232   3                              case 3:
 233   3                                      if(--i > 3) 
 234   3                                      {i=0;x.mode=4;}
 235   3                              break;
 236   3                              case 4:
 237   3                                      if(++i > 3) 
 238   3                                      {i=0;x.mode=1;}
 239   3                              break;
 240   3                      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2024 16:27:45 PAGE 5   

 241   2              }
 242   1      }
 243          //**********************************
 244          void blink8_mainloop(void)
 245          {
 246   1              u8 i=0,tmp = 0;
 247   1              
 248   1              if (!f_800ms_blink8) return;//500ms
 249   1              f_800ms_blink8 = 0;
 250   1              
 251   1              if(blink8_dat == 0)return;
 252   1              
 253   1              for(i = 0;i <8;i++)
 254   1              {
 255   2                      tmp  = blink8_dat & (1 << i);
 256   2                      if(tmp)
 257   2                              dis_blink[i] = ~dis_blink[i];
 258   2                      else
 259   2                              dis_blink[i] = 0;
 260   2              }
 261   1      }
 262          //*********************************************
 263          void adc_mainloop(void)//采集亮度
 264          {
 265   1              u8 ad_temp = 0;
 266   1              if(!f_100ms_adc) return;
 267   1              f_100ms_adc = 0;
 268   1              
 269   1              ad_temp = read_adc();
 270   1              x.adc = (4 * (u16)ad_temp / 256)+1;
 271   1              x.l = x.adc;
 272   1      }
 273          //***************************
 274          void Delay10ms()                //@12.000MHz
 275          {
 276   1              unsigned char i, j;
 277   1      
 278   1              i = 117;
 279   1              j = 184;
 280   1              do
 281   1              {
 282   2                      while (--j);
 283   2              } while (--i);
 284   1      }
 285          //***********************
 286          void e2prom_init(void)
 287          {
 288   1              //eeprom
 289   1              x.t1 = read_e2prom(0x01);
 290   1              if(x.t1 > 13 || x.t1 < 3)
 291   1              {
 292   2                      write_e2prom(0x01,4);//初始化间隔
 293   2                      Delay10ms();
 294   2              }
 295   1              x.t1 = read_e2prom(0x01);
 296   1              //
 297   1              x.t2 = read_e2prom(0x02);
 298   1              if(x.t2 > 13 || x.t2 < 3)
 299   1              {
 300   2                      write_e2prom(0x02,4);//初始化间隔
 301   2                      Delay10ms();
 302   2              }
C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2024 16:27:45 PAGE 6   

 303   1              x.t2 = read_e2prom(0x02);
 304   1              //
 305   1              x.t3 = read_e2prom(0x03);
 306   1              if(x.t3 > 13 || x.t3 < 3)
 307   1              {
 308   2                      write_e2prom(0x03,4);//初始化间隔
 309   2                      Delay10ms();
 310   2              }
 311   1              x.t3 = read_e2prom(0x03);
 312   1              //
 313   1              x.t4 = read_e2prom(0x04);
 314   1              if(x.t4 > 13 || x.t4 < 3)
 315   1              {
 316   2                      write_e2prom(0x04,4);//初始化间隔
 317   2                      Delay10ms();
 318   2              }
 319   1              x.t4 = read_e2prom(0x04);
 320   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1403    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =     16    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
